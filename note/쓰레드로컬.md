## 문제점

- 앞서 로그 추적기를 개발하면서 트랜잭션ID, LEVEL을 동기화하는 문제를 해결하기 위해 인터페이스 도입

하나의 쓰레드로 트래픽이 많아지게 되면 쓰레드를 공유하면서 쓰기 때문에 동시성 이슈가 발생함

## 동시성 이슈
- 여러 쓰레드가 동시에 같은 인스턴스 필드값을 가지고 업데이트, 등록 하게 되면 나타나는 문제를 동시성 문제로 발생함
- 조심해야 할때는 스프링 처럼 싱글톤 객체를 필드로 변경하며 사용 시에 많이 발생하게 된다.
- 동시성 문제는 값을 읽기만 할때는 발생하지 않고, 어디선가 값을 변경할 때 발생한다.

## ThreadLocal
- 각 쓰레드마다 별도의 내부저장소를 지원하기 때문에 같은 인스턴스에 여러 트래픽이 사용해도 각각 저장소를 사용하여 데이터 동시성 문제를 막을 수 있음
- 자바는 언어 차원에서 쓰레드 로컬을 지원하기 위한 java.lang.ThreadLocal 클래스를 지원한다.


### ThreadLocal.remove()
- 쓰레드 로컬을 모두 사용하고 나면 ThreadLocal.remove()를 호출 하여 각각 쓰레드에 저장된 값을 제거해줘야한다.

![스크린샷 2024-03-24 오후 4 01 18](https://github.com/yunhwane/spring-advanced/assets/147581818/166350c8-2cf4-4784-ad88-d119bed61720)

### 작동원리
1. 사용자 A가 저장 HTTP 요청
2. WAS는 쓰레드 풀에서 쓰레드를 할당
3. 할당된 쓰레드는 사용자 A의 데이터를 쓰레드 로컬에 저장
4. 쓰레드 로컬의 할당된 데이터 저장소에서 사용자 A의 데이터를 저장한다.

![스크린샷 2024-03-24 오후 4 03 18](https://github.com/yunhwane/spring-advanced/assets/147581818/feb842a1-04dc-4cdf-a4bb-e1d7a09ba73c)

1. 사용자의 HTTP 응답이 끝난다.
2. WAS는 사용이 끝난 쓰레드를 쓰레드 풀에 반환한다.
3. 쓰레드 풀에서 반환된 쓰레드는 계속 데이터를 유지하기 때문에 사용자 A의 데이터도 함께 사용하고 있다.

![스크린샷 2024-03-24 오후 4 04 51](https://github.com/yunhwane/spring-advanced/assets/147581818/6212fad6-dbf3-4f8f-997b-56c48ea5e9ed)

1. 사용자 B가 데이터를 조회하기 위해 HTTP 요청을 보낸다.
2. WAS는 쓰레드 풀에서 쓰레드를 하나 할당한다.
3. 그게 만약 사용자 A의 할당된 쓰레드면, 사용자 A의 전용 보관소에 있는 사용자 A값을 반환하게 된다.
4. 즉, 사용자 B는 사용자 A의 정보를 조회하게 된다.

### 추가 정보
ThreadLocal.remove()는 그 쓰레드의 정보를 제거한다.
